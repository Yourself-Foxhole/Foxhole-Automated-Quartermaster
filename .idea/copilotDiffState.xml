<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env" />
              <option name="updatedContent" value="# .env&#10;# Environment variables for Discord bot&#10;# Uncomment and set these as needed&#10;&#10;# DISCORD_BOT_TOKEN=your_token_here&#10;# DISCORD_BOT_MAX_RETRIES=3&#10;# DISCORD_BOT_RETRY_DELAY=15&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# .env.example&#10;# Example environment file for Discord bot retry mechanism&#10;# Copy this file to .env and set your own values as needed&#10;&#10;# Discord bot token (required)&#10;DISCORD_BOT_TOKEN=your_token_here&#10;&#10;# Optional retry mechanism settings&#10;# Number of times to retry connecting after a failure (default: 3)&#10;DISCORD_BOT_MAX_RETRIES=3&#10;# Delay in seconds between retries (default: 15)&#10;DISCORD_BOT_RETRY_DELAY=15&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.git/hooks/pre-push.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.git/hooks/pre-push.ps1" />
              <option name="updatedContent" value="# PowerShell pre-push hook to block pushes to production if Bandit finds issues&#10;&#10;$branch = git rev-parse --abbrev-ref HEAD&#10;if ($branch -eq &quot;main&quot; -or $branch -eq &quot;master&quot; -or $branch -eq &quot;production&quot;) {&#10;    Write-Host &quot;Running Bandit security checks before pushing to production...&quot;&#10;    bandit -r .&#10;    if ($LASTEXITCODE -ne 0) {&#10;        Write-Host &quot;Bandit found security issues. Push to production is blocked.&quot;&#10;        exit 1&#10;    }&#10;}&#10;exit 0&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/discord/__init__.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/discord/__init__.py" />
              <option name="updatedContent" value="# Makes discord a package" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_ruff.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_ruff.py" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;# Default path to check is current directory&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;try:&#10;    result = subprocess.run([&quot;ruff&quot;, path], check=False)&#10;    sys.exit(result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;Ruff is not installed. Please install it with 'pip install ruff'.&quot;)&#10;    sys.exit(1)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/data/discord/test_retry_env.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/data/discord/test_retry_env.py" />
              <option name="originalContent" value="import asyncio&#10;&#10;# Assume DiscordBot is imported from the correct location&#10;    # Ensure an event loop exists for tests that need it&#10;        loop = asyncio.new_event_loop()&#10;    # Clean up the event loop after each test&#10;    try:&#10;        asyncio.get_event_loop()&#10;        loop.close()&#10;    except RuntimeError:&#10;        pass&#10;&#10;def test_env_defaults(monkeypatch):&#10;    # Remove env vars if set&#10;    monkeypatch.delenv('DISCORD_BOT_MAX_RETRIES', raising=False)&#10;    monkeypatch.delenv('DISCORD_BOT_RETRY_DELAY', raising=False)&#10;    # Access the retry config (simulate how your code reads it)&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 3&#10;    assert retry_delay == 15&#10;&#10;def test_env_override(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '5')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '42')&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 5&#10;    assert retry_delay == 42&#10;&#10;def test_retry_on_exception(monkeypatch):&#10;    # Set retries to 2 for a quick test&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')  # No sleep delay&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()  # Mock logger to avoid real logging&#10;    # Mock client.run to always raise Exception&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should attempt to run 1 initial + 2 retries = 3 times&#10;    assert bot.client.run.call_count == 3&#10;    # Check that error and retry logs were called&#10;    assert bot.logger.error.call_count &gt;= 3&#10;    assert any('Attempting to reconnect' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_login_failure(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Mock client.run to raise LoginFailure&#10;    bot.client.run = mock.Mock(side_effect=LoginFailure('bad token'))&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    # Should only try once&#10;    assert bot.client.run.call_count == 1&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_no_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '0')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should only try once (no retries)&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_negative_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '-1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Class should only try once. Negative retries are treated as 0.&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_non_integer_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', 'abc')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_non_integer_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', 'xyz')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_zero_retry_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    # Patch sleep to track calls&#10;    with mock.patch('time.sleep') as mock_sleep:&#10;        with pytest.raises(Exception):&#10;            bot.run()&#10;        # Should attempt to run 1 initial + 2 retries = 3 times&#10;        assert bot.client.run.call_count == 3&#10;        # sleep should not be called since delay is 0&#10;        mock_sleep.assert_not_called()&#10;&#10;def test_retry_succeeds(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # First call fails, second call succeeds&#10;    bot.client.run = mock.Mock(side_effect=[Exception('fail'), None])&#10;    # Should not raise, since the second attempt succeeds&#10;    bot.run()&#10;    assert bot.client.run.call_count == 2&#10;    # Should log error for first failure, but not raise&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_shutdown_exception(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    bot.client.close = mock.Mock(side_effect=Exception('shutdown fail'))&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    # Should log the shutdown error&#10;    assert any('shutdown fail' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_on_ready_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Simulate event&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_sets_disconnected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;class DummyUser:&#10;    def __str__(self):&#10;        return &quot;TestUser&quot;&#10;&#10;def test_on_ready_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client with a mock that has a user property&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as TestUser' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_run_login_failure_non_mock(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client to not be a mock&#10;    class DummyClient:&#10;        def run(self, token):&#10;            raise LoginFailure('bad token')&#10;    bot.client = DummyClient()&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_shutdown_running_loop_add_done_callback(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = True&#10;            # Simulate create_task and add_done_callback&#10;            class DummyTask:&#10;                def add_done_callback(self, cb):&#10;                    cb(self)&#10;            mock_loop.create_task = mock.Mock(return_value=DummyTask())&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_shutdown_returns_if_client_closed(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=True)&#10;    # Should return early, not call close&#10;    bot.client.close = mock.Mock()&#10;    bot.shutdown()&#10;    bot.client.close.assert_not_called()&#10;&#10;def test_shutdown_returns_if_client_is_mock(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client = mock.Mock()&#10;    bot.client.is_closed.return_value = False&#10;    # Should return early if the client is a mock&#10;    bot.shutdown()&#10;    # Should not call close or log warning&#10;    assert not bot.logger.warning.called&#10;&#10;def test_shutdown_logs_warning_if_close_not_awaitable(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    # close returns a non-awaitable&#10;    bot.client.close = mock.Mock(return_value=None)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('did not return a coroutine' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_shutdown_logs_graceful_disconnect(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            # Simulate run_until_complete&#10;            def run_until_complete():&#10;                return None&#10;            mock_loop.run_until_complete = run_until_complete&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_is_connected():&#10;    bot = DiscordBot(token='dummy')&#10;    bot.connected = True&#10;    assert bot.is_connected() is True&#10;    bot.connected = False&#10;    assert bot.is_connected() is False&#10;" />
              <option name="updatedContent" value="import sys&#10;import os&#10;import pytest&#10;from unittest import mock&#10;import asyncio&#10;&#10;# Add the project root to sys.path so 'data' can be imported&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../..')))&#10;&#10;# Assume DiscordBot is imported from the correct location&#10;from data.discord.discord import DiscordBot&#10;&#10;def setup_function():&#10;    # Ensure an event loop exists for tests that need it&#10;    try:&#10;        asyncio.get_running_loop()&#10;    except RuntimeError:&#10;        loop = asyncio.new_event_loop()&#10;        asyncio.set_event_loop(loop)&#10;&#10;def teardown_function():&#10;    # Clean up the event loop after each test&#10;    try:&#10;        loop = asyncio.get_event_loop()&#10;        loop.close()&#10;    except RuntimeError:&#10;        pass&#10;&#10;def test_env_defaults(monkeypatch):&#10;    # Remove env vars if set&#10;    monkeypatch.delenv('DISCORD_BOT_MAX_RETRIES', raising=False)&#10;    monkeypatch.delenv('DISCORD_BOT_RETRY_DELAY', raising=False)&#10;    # Access the retry config (simulate how your code reads it)&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 3&#10;    assert retry_delay == 15&#10;&#10;def test_env_override(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '5')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '42')&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 5&#10;    assert retry_delay == 42&#10;&#10;def test_retry_on_exception(monkeypatch):&#10;    # Set retries to 2 for a quick test&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')  # No sleep delay&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()  # Mock logger to avoid real logging&#10;    # Mock client.run to always raise Exception&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should attempt to run 1 initial + 2 retries = 3 times&#10;    assert bot.client.run.call_count == 3&#10;    # Check that error and retry logs were called&#10;    assert bot.logger.error.call_count &gt;= 3&#10;    assert any('Attempting to reconnect' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_login_failure(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Mock client.run to raise LoginFailure&#10;    bot.client.run = mock.Mock(side_effect=LoginFailure('bad token'))&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    # Should only try once&#10;    assert bot.client.run.call_count == 1&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_no_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '0')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should only try once (no retries)&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_negative_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '-1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Class should only try once. Negative retries are treated as 0.&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_non_integer_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', 'abc')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_non_integer_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', 'xyz')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_zero_retry_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    # Patch sleep to track calls&#10;    with mock.patch('time.sleep') as mock_sleep:&#10;        with pytest.raises(Exception):&#10;            bot.run()&#10;        # Should attempt to run 1 initial + 2 retries = 3 times&#10;        assert bot.client.run.call_count == 3&#10;        # sleep should not be called since delay is 0&#10;        mock_sleep.assert_not_called()&#10;&#10;def test_retry_succeeds(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # First call fails, second call succeeds&#10;    bot.client.run = mock.Mock(side_effect=[Exception('fail'), None])&#10;    # Should not raise, since the second attempt succeeds&#10;    bot.run()&#10;    assert bot.client.run.call_count == 2&#10;    # Should log error for first failure, but not raise&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_shutdown_exception(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    bot.client.close = mock.Mock(side_effect=Exception('shutdown fail'))&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    # Should log the shutdown error&#10;    assert any('shutdown fail' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_on_ready_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Simulate event&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_sets_disconnected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;class DummyUser:&#10;    def __str__(self):&#10;        return &quot;TestUser&quot;&#10;&#10;def test_on_ready_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client with a mock that has a user property&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as TestUser' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_run_login_failure_non_mock(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client to not be a mock&#10;    class DummyClient:&#10;        def run(self, token):&#10;            raise LoginFailure('bad token')&#10;    bot.client = DummyClient()&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_shutdown_running_loop_add_done_callback(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = True&#10;            # Simulate create_task and add_done_callback&#10;            class DummyTask:&#10;                def add_done_callback(self, cb):&#10;                    cb(self)&#10;            mock_loop.create_task = mock.Mock(return_value=DummyTask())&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_shutdown_returns_if_client_closed(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=True)&#10;    # Should return early, not call close&#10;    bot.client.close = mock.Mock()&#10;    bot.shutdown()&#10;    bot.client.close.assert_not_called()&#10;&#10;def test_shutdown_returns_if_client_is_mock(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client = mock.Mock()&#10;    bot.client.is_closed.return_value = False&#10;    # Should return early if the client is a mock&#10;    bot.shutdown()&#10;    # Should not call close or log warning&#10;    assert not bot.logger.warning.called&#10;&#10;def test_shutdown_logs_warning_if_close_not_awaitable(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    # close returns a non-awaitable&#10;    bot.client.close = mock.Mock(return_value=None)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('did not return a coroutine' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_shutdown_logs_graceful_disconnect(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            # Simulate run_until_complete&#10;            def run_until_complete():&#10;                return None&#10;            mock_loop.run_until_complete = run_until_complete&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_is_connected():&#10;    bot = DiscordBot(token='dummy')&#10;    bot.connected = True&#10;    assert bot.is_connected() is True&#10;    bot.connected = False&#10;    assert bot.is_connected() is False" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/runners/bandit_runner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/runners/bandit_runner.py" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;try:&#10;    result = subprocess.run([&quot;bandit&quot;, &quot;-r&quot;, path], check=False)&#10;    sys.exit(result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;Bandit is not installed. Please install it with 'pip install bandit'.&quot;)&#10;    sys.exit(1)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/runners/pycov_runner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/runners/pycov_runner.py" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;# Default test path is current directory or user-specified&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;try:&#10;    result = subprocess.run([&#10;        &quot;pytest&quot;, &quot;--cov&quot;, path, &quot;--cov-report=term-missing&quot;&#10;    ], check=False)&#10;    sys.exit(result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;pytest or pytest-cov is not installed. Please install them with 'pip install pytest pytest-cov'.&quot;)&#10;    sys.exit(1)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/runners/ruff_runner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/runners/ruff_runner.py" />
              <option name="originalContent" value="import subprocess&#10;import sys&#10;&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;try:&#10;    result = subprocess.run([&quot;ruff&quot;, path], check=False)&#10;    sys.exit(result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;Ruff is not installed. Please install it with 'pip install ruff'.&quot;)&#10;    sys.exit(1)" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;# Run Ruff linter&#10;try:&#10;    print(&quot;Running Ruff linter...&quot;)&#10;    lint_result = subprocess.run([&quot;ruff&quot;, path], check=False)&#10;    if lint_result.returncode != 0:&#10;        print(&quot;Ruff linting issues found.&quot;)&#10;    else:&#10;        print(&quot;Ruff linting passed.&quot;)&#10;except FileNotFoundError:&#10;    print(&quot;Ruff is not installed. Please install it with 'pip install ruff'.&quot;)&#10;    sys.exit(1)&#10;&#10;# Run Ruff formatter&#10;try:&#10;    print(&quot;Running Ruff formatter...&quot;)&#10;    fmt_result = subprocess.run([&quot;ruff&quot;, &quot;format&quot;, path], check=False)&#10;    if fmt_result.returncode != 0:&#10;        print(&quot;Ruff formatting issues found.&quot;)&#10;    else:&#10;        print(&quot;Ruff formatting passed.&quot;)&#10;except FileNotFoundError:&#10;    print(&quot;Ruff is not installed. Please install it with 'pip install ruff'.&quot;)&#10;    sys.exit(1)&#10;&#10;# Exit with nonzero if either failed&#10;if lint_result.returncode != 0 or fmt_result.returncode != 0:&#10;    sys.exit(1)&#10;sys.exit(0)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/runners/run_quality_checks.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/runners/run_quality_checks.py" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;runners = [&#10;    (&quot;Ruff&quot;, &quot;ruff_runner.py&quot;),&#10;    (&quot;Safety&quot;, &quot;safety_runner.py&quot;),&#10;    (&quot;Vulture&quot;, &quot;vulture_runner.py&quot;),&#10;    (&quot;Bandit&quot;, &quot;bandit_runner.py&quot;),&#10;    (&quot;Pytest-Cov&quot;, &quot;pycov_runner.py&quot;),&#10;]&#10;&#10;base_path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;for name, script in runners:&#10;    print(f&quot;\n=== Running {name} ===&quot;)&#10;    result = subprocess.run([sys.executable, script, base_path], cwd=&quot;./tests/runners&quot;)&#10;    if result.returncode != 0:&#10;        print(f&quot;{name} checks failed.&quot;)&#10;    else:&#10;        print(f&quot;{name} checks passed.&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/runners/safety_runner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/runners/safety_runner.py" />
              <option name="originalContent" value="import subprocess&#10;import sys&#10;&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;try:&#10;    result = subprocess.run([&quot;safety&quot;, &quot;check&quot;, &quot;--full-report&quot;], check=False)&#10;    sys.exit(result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;Safety is not installed. Please install it with 'pip install safety'.&quot;)&#10;    sys.exit(1)&#10;&#10;" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;# Try safety login first&#10;try:&#10;    print(&quot;Logging in to Safety...&quot;)&#10;    login_result = subprocess.run([&quot;safety&quot;, &quot;login&quot;], check=False)&#10;    if login_result.returncode != 0:&#10;        print(&quot;Safety login failed or not required. Proceeding without login.&quot;)&#10;except FileNotFoundError:&#10;    print(&quot;Safety is not installed. Please install it with 'pip install safety'.&quot;)&#10;    sys.exit(1)&#10;&#10;# Try safety scan (preferred)&#10;try:&#10;    print(&quot;Running Safety scan...&quot;)&#10;    scan_result = subprocess.run([&quot;safety&quot;, &quot;scan&quot;, &quot;--full-report&quot;], check=False)&#10;    if scan_result.returncode == 0:&#10;        sys.exit(0)&#10;    else:&#10;        print(&quot;Safety scan failed or not available. Trying safety check...&quot;)&#10;        # Fallback to safety check&#10;        check_result = subprocess.run([&quot;safety&quot;, &quot;check&quot;, &quot;--full-report&quot;], check=False)&#10;        sys.exit(check_result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;Safety is not installed. Please install it with 'pip install safety'.&quot;)&#10;    sys.exit(1)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/runners/vulture_runner.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/runners/vulture_runner.py" />
              <option name="updatedContent" value="import subprocess&#10;import sys&#10;&#10;path = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;.&quot;&#10;&#10;try:&#10;    result = subprocess.run([&quot;vulture&quot;, path], check=False)&#10;    sys.exit(result.returncode)&#10;except FileNotFoundError:&#10;    print(&quot;Vulture is not installed. Please install it with 'pip install vulture'.&quot;)&#10;    sys.exit(1)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>