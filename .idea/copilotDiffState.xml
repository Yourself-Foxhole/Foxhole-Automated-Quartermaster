<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/data/discord/discord.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/discord/discord.py" />
              <option name="originalContent" value="# The purpose of this file is the maintain the data interactions for the Discord bot." />
              <option name="updatedContent" value="import logging&#10;from disnake import Client, Intents, LoginFailure&#10;&#10;# The purpose of this file is the maintain the data interactions for the Discord bot.&#10;&#10;class DiscordBot:&#10;    def __init__(self, token: str, intents: Intents = None):&#10;        self.token = token&#10;        self.intents = intents or Intents.default()&#10;        self.client = Client(intents=self.intents)&#10;        self.connected = False&#10;        self.logger = logging.getLogger(&quot;DiscordBot&quot;)&#10;        self._register_events()&#10;&#10;    def _register_events(self):&#10;        @self.client.event&#10;        async def on_ready():&#10;            self.connected = True&#10;            self.logger.info(f&quot;Connected to Discord as {self.client.user}&quot;)&#10;&#10;        @self.client.event&#10;        async def on_disconnect():&#10;            self.connected = False&#10;            self.logger.warning(&quot;Disconnected from Discord. Attempting to reconnect...&quot;)&#10;&#10;        @self.client.event&#10;        async def on_resumed():&#10;            self.connected = True&#10;            self.logger.info(&quot;Reconnected to Discord.&quot;)&#10;&#10;    def run(self):&#10;        try:&#10;            self.logger.info(&quot;Starting Discord bot...&quot;)&#10;            self.client.run(self.token)&#10;        except LoginFailure as e:&#10;            self.logger.error(f&quot;Authentication failed: {e}&quot;)&#10;            # Optionally notify admin here&#10;            raise&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Connection error: {e}&quot;)&#10;            raise&#10;&#10;    def shutdown(self):&#10;        self.logger.info(&quot;Shutting down Discord bot...&quot;)&#10;        try:&#10;            import asyncio&#10;            loop = asyncio.get_event_loop()&#10;            if self.client.is_closed():&#10;                return&#10;            loop.run_until_complete(self.client.close())&#10;            self.logger.info(&quot;Bot disconnected gracefully.&quot;)&#10;        except Exception as e:&#10;            self.logger.error(f&quot;Error during shutdown: {e}&quot;)&#10;&#10;    def is_connected(self):&#10;        return self.connected" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docs-implementation/discord-user-stories.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docs-implementation/discord-user-stories.md" />
              <option name="originalContent" value="This file should contain user stories and other planning tools for implementation of a certain part of the project.&#10;&#10;&#10;## Discord Data Layer&#10;&#10;This set of features is effectively our front end. This layer handles pure interaction with the discord service.&#10;&#10;Features:&#10;&#10;* Connect and maintain a connection to discord&#10;* Be able to create multiple channels and threads&#10;* Be able to listen for commands&#10;* Be able to post embeds, the primary post type&#10;* Be able to update dashboard posts with current information&#10;* Be able to parse screenshots, downloading them to handoff to the data layer&#10;* Be able to update and manage reactions on posts&#10;* Be able to crosspost updates between channels where needed&#10;&#10;&#10;## User Stories&#10;&#10;### Connection&#10;&#10;Feature: The Bot manages a connection to discord.&#10;&#10;Scenario: When the bot is running, the bot maintains a constant connection to the discord service.&#10;&#10;" />
              <option name="updatedContent" value="This file should contain user stories and other planning tools for implementation of a certain part of the project.&#10;&#10;&#10;## Discord Data Layer&#10;&#10;This set of features is effectively our front end. This layer handles pure interaction with the discord service.&#10;&#10;Features:&#10;&#10;* Connect and maintain a connection to discord&#10;* Be able to create multiple channels and threads&#10;* Be able to listen for commands&#10;* Be able to post embeds, the primary post type&#10;* Be able to update dashboard posts with current information&#10;* Be able to parse screenshots, downloading them to handoff to the data layer&#10;* Be able to update and manage reactions on posts&#10;* Be able to crosspost updates between channels where needed&#10;&#10;&#10;## User Stories&#10;&#10;### Connection&#10;&#10;Feature: The Bot manages a connection to Discord.&#10;&#10;As a user,&#10;I want the bot to maintain a constant and reliable connection to the Discord service,&#10;So that I can always interact with it and receive timely updates.&#10;&#10;#### Scenarios&#10;&#10;**Scenario 1: Bot starts and connects to Discord**&#10;- Given the bot is started&#10;- When the bot initializes&#10;- Then it should establish a connection to the Discord API&#10;- And log a successful connection event&#10;&#10;**Scenario 2: Bot maintains connection**&#10;- Given the bot is running&#10;- When the Discord connection is interrupted (e.g., network issue)&#10;- Then the bot should attempt to automatically reconnect&#10;- And log reconnection attempts and results&#10;&#10;**Scenario 3: Bot handles authentication errors**&#10;- Given the bot is running&#10;- When the Discord API returns an authentication error&#10;- Then the bot should log the error&#10;- And notify the administrator if possible&#10;&#10;**Scenario 4: Bot disconnects gracefully**&#10;- Given the bot is running&#10;- When the bot is intentionally stopped or restarted&#10;- Then it should disconnect from Discord gracefully&#10;- And log the disconnection event&#10;&#10;**Acceptance Criteria:**&#10;- The bot must connect to Discord on startup and log the event.&#10;- The bot must attempt to reconnect automatically if disconnected unexpectedly.&#10;- The bot must handle and log authentication or connection errors.&#10;- The bot must disconnect gracefully on shutdown." />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/data/discord/bot-connection.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/data/discord/bot-connection.py" />
              <option name="originalContent" value="import unittest&#10;from unittest.mock import patch&#10;&#10;&#10;class TestDiscordBotConnection(unittest.TestCase):&#10;    @patch('data.discord.discord.Client')&#10;    def test_startup_connection(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        instance.run.return_value = None&#10;        # Act&#10;        from data.discord import discord&#10;        bot = instance&#10;        bot.run('fake_token')&#10;        # Assert&#10;        instance.run.assert_called_with('fake_token')&#10;&#10;    @patch('data.discord.discord.Client')&#10;    def test_automatic_reconnection(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        instance.run.side_effect = [Exception('disconnect'), None]&#10;        # Act&#10;        from data.discord import discord&#10;        bot = instance&#10;        try:&#10;            bot.run('fake_token')&#10;        except Exception:&#10;            # Simulate reconnect&#10;            bot.run('fake_token')&#10;        # Assert&#10;        self.assertEqual(instance.run.call_count, 2)&#10;&#10;    @patch('data.discord.discord.Client')&#10;    def test_authentication_error_handling(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        instance.run.side_effect = Exception('authentication failed')&#10;        # Act &amp; Assert&#10;        from data.discord import discord&#10;        bot = instance&#10;        with self.assertRaises(Exception) as context:&#10;            bot.run('bad_token')&#10;        self.assertIn('authentication failed', str(context.exception))&#10;&#10;    @patch('data.discord.discord.Client')&#10;    def test_graceful_shutdown(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        instance.close.return_value = None&#10;        # Act&#10;        from data.discord import discord&#10;        bot = instance&#10;        bot.close()&#10;        # Assert&#10;        instance.close.assert_called_once()&#10;&#10;&#10;if __name__ == '__main__':&#10;    unittest.main()&#10;" />
              <option name="updatedContent" value="import unittest&#10;from unittest.mock import patch&#10;from data.discord.discord import DiscordBot&#10;&#10;&#10;class TestDiscordBotConnection(unittest.TestCase):&#10;    @patch('data.discord.discord.Client')&#10;    def test_startup_connection(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        instance.run.return_value = None&#10;        bot = DiscordBot(token='fake_token')&#10;        # Act&#10;        bot.run()&#10;        # Assert&#10;        instance.run.assert_called_with('fake_token')&#10;&#10;    @patch('data.discord.discord.Client')&#10;    def test_automatic_reconnection(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        # Simulate disconnect and reconnect by raising and then not raising&#10;        instance.run.side_effect = [Exception('disconnect'), None]&#10;        bot = DiscordBot(token='fake_token')&#10;        # Act&#10;        try:&#10;            bot.run()&#10;        except Exception:&#10;            # Simulate reconnect&#10;            bot.run()&#10;        # Assert&#10;        self.assertEqual(instance.run.call_count, 2)&#10;&#10;    @patch('data.discord.discord.Client')&#10;    def test_authentication_error_handling(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        from disnake import LoginFailure&#10;        instance.run.side_effect = LoginFailure('authentication failed')&#10;        bot = DiscordBot(token='bad_token')&#10;        # Act &amp; Assert&#10;        with self.assertRaises(LoginFailure) as context:&#10;            bot.run()&#10;        self.assertIn('authentication failed', str(context.exception))&#10;&#10;    @patch('data.discord.discord.Client')&#10;    def test_graceful_shutdown(self, mock_client):&#10;        # Arrange&#10;        instance = mock_client.return_value&#10;        instance.is_closed.return_value = False&#10;        instance.close.return_value = None&#10;        bot = DiscordBot(token='fake_token')&#10;        # Act&#10;        bot.shutdown()&#10;        # Assert&#10;        instance.close.assert_called_once()&#10;&#10;&#10;if __name__ == '__main__':&#10;    unittest.main()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/data/discord/discord-bot-test-plan.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/data/discord/discord-bot-test-plan.md" />
              <option name="originalContent" value="# Discord Bot Test Plan&#10;&#10;This document outlines the test plan for the Discord bot portion of the Foxhole Automated Quartermaster project, following the 4-layer architecture described in the project documentation.&#10;&#10;---&#10;&#10;## 1. Model Layer&#10;- **Database ORM (Peewee):**&#10;  - Test CRUD operations for inventory, tasks, and unit states.&#10;  - Validate database connection and schema migrations.&#10;- **Discord Presence (disnake):**&#10;  - Verify bot can connect, disconnect, and reconnect to Discord.&#10;  - Test presence/status updates and event handling.&#10;&#10;## 2. Service Layer&#10;- **Graph Processing:**&#10;  - Validate creation, update, and deletion of nodes and edges.&#10;- **State Management:**&#10;  - Ensure correct state transitions for units and inventory.&#10;- **Queries:**&#10;  - Confirm accurate data retrieval and filtering.&#10;- **OCR Integration:**&#10;  - Mock FIR responses and validate OCR data handling.&#10;&#10;## 3. Data Pipeline&#10;- **Screenshot Parsing:**&#10;  - Simulate image input and verify correct parsing to FIR data.&#10;- **Event-Driven Updates:**&#10;  - Ensure events trigger correct service calls and updates.&#10;- **Batch Analysis:**&#10;  - Validate inventory delta and production target calculations.&#10;&#10;## 4. Presentation Layer&#10;- **Message Formatting:**&#10;  - Ensure dashboards, task boards, and embeds are correctly generated.&#10;- **Command Handling:**&#10;  - Validate responses to commands, button presses, and reactions.&#10;- **Error Handling:**&#10;  - Confirm appropriate error messages and fallback behaviors.&#10;&#10;## 5. Integration Tests&#10;- Simulate end-to-end flows:&#10;  - Screenshot upload → OCR → Inventory update → Dashboard post.&#10;  - User command → Service query → Message/Embed response.&#10;- Test concurrency and event ordering.&#10;- Test permission and access control for Discord commands.&#10;&#10;## 6. Edge Cases &amp; Negative Tests&#10;- Invalid or corrupted image uploads.&#10;- Database or Discord connection failures.&#10;- Unexpected user input or command misuse.&#10;&#10;## 7. Performance &amp; Reliability&#10;- Test bot responsiveness under load.&#10;- Test recovery from service interruptions.&#10;&#10;---&#10;&#10;This plan covers unit, integration, and system-level tests for the Discord bot, ensuring reliability across all architectural layers.&#10;&#10;" />
              <option name="updatedContent" value="# Discord Bot Test Plan&#10;&#10;This document outlines the test plan for the Discord bot portion of the Foxhole Automated Quartermaster project, following the 4-layer architecture described in the project documentation.&#10;&#10;---&#10;&#10;## 1. Model Layer&#10;- **Database ORM (Peewee):**&#10;  - Test CRUD operations for inventory, tasks, and unit states.&#10;  - Validate database connection and schema migrations.&#10;- **Discord Presence (disnake):**&#10;  - Verify bot can connect, disconnect, and reconnect to Discord.&#10;  - Test presence/status updates and event handling.&#10;&#10;## 2. Service Layer&#10;- **Graph Processing:**&#10;  - Validate creation, update, and deletion of nodes and edges.&#10;- **State Management:**&#10;  - Ensure correct state transitions for units and inventory.&#10;- **Queries:**&#10;  - Confirm accurate data retrieval and filtering.&#10;- **OCR Integration:**&#10;  - Mock FIR responses and validate OCR data handling.&#10;&#10;## 3. Data Pipeline&#10;- **Screenshot Parsing:**&#10;  - Simulate image input and verify correct parsing to FIR data.&#10;- **Event-Driven Updates:**&#10;  - Ensure events trigger correct service calls and updates.&#10;- **Batch Analysis:**&#10;  - Validate inventory delta and production target calculations.&#10;&#10;## 4. Presentation Layer&#10;- **Message Formatting:**&#10;  - Ensure dashboards, task boards, and embeds are correctly generated.&#10;- **Command Handling:**&#10;  - Validate responses to commands, button presses, and reactions.&#10;- **Error Handling:**&#10;  - Confirm appropriate error messages and fallback behaviors.&#10;&#10;## 5. Integration Tests&#10;- Simulate end-to-end flows:&#10;  - Screenshot upload → OCR → Inventory update → Dashboard post.&#10;  - User command → Service query → Message/Embed response.&#10;- Test concurrency and event ordering.&#10;- Test permission and access control for Discord commands.&#10;&#10;## 6. Edge Cases &amp; Negative Tests&#10;- Invalid or corrupted image uploads.&#10;- Database or Discord connection failures.&#10;- Unexpected user input or command misuse.&#10;&#10;## 7. Performance &amp; Reliability&#10;- Test bot responsiveness under load.&#10;- Test recovery from service interruptions.&#10;&#10;## Test Plan: Connection Management (TDD)&#10;&#10;### Purpose&#10;To ensure the Discord bot reliably connects, maintains, and gracefully handles its connection to Discord, as described in the user story.&#10;&#10;### Test Cases&#10;&#10;#### 1. Bot Startup Connection&#10;- **Test:** When the bot starts, it should attempt to connect to Discord.&#10;- **Arrange:** Mock Discord API and bot token.&#10;- **Act:** Start the bot.&#10;- **Assert:** Verify connection method is called and a successful connection event is logged.&#10;&#10;#### 2. Automatic Reconnection&#10;- **Test:** If the connection is lost, the bot should attempt to reconnect automatically.&#10;- **Arrange:** Simulate a network interruption or forced disconnect.&#10;- **Act:** Observe bot behavior after disconnect.&#10;- **Assert:** Verify reconnection attempts and that reconnection events are logged.&#10;&#10;#### 3. Authentication Error Handling&#10;- **Test:** The bot should handle authentication errors gracefully.&#10;- **Arrange:** Provide an invalid or expired token.&#10;- **Act:** Start the bot.&#10;- **Assert:** Verify error is logged and administrator is notified (if implemented).&#10;&#10;#### 4. Graceful Shutdown&#10;- **Test:** The bot should disconnect gracefully on shutdown.&#10;- **Arrange:** Start the bot and connect to Discord.&#10;- **Act:** Trigger a shutdown or restart.&#10;- **Assert:** Verify disconnect method is called and disconnection event is logged.&#10;&#10;### Acceptance Criteria&#10;- All tests above must pass before feature is considered complete.&#10;- Tests should be automated and run as part of CI/CD pipeline.&#10;&#10;### Notes&#10;- Use mocking frameworks to simulate Discord API responses and network conditions.&#10;- Log outputs should be captured and asserted in tests.&#10;- Consider edge cases such as repeated failures, rate limits, and partial outages.&#10;&#10;---&#10;&#10;This plan covers unit, integration, and system-level tests for the Discord bot, ensuring reliability across all architectural layers." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>