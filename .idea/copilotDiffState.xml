<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/data/db/materials.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/db/materials.py" />
              <option name="originalContent" value="from enum import Enum&#10;&#10;class Material(Enum):&#10;    BMAT = &quot;Basic Material&quot;&#10;    RMAT = &quot;Refined Material&quot;&#10;    EMAT = &quot;Explosive Powder&quot;&#10;    HEMAT = &quot;High Explosive Powder&quot;&#10;    PCMAT = &quot;Processed Construction Material&quot;&#10;    CMAT = &quot;Construction Material&quot;&#10;    AMAT1 = &quot;Assembly Material I&quot;&#10;    AMAT2 = &quot;Assembly Material II&quot;&#10;    AMAT3 = &quot;Assembly Material III&quot;&#10;    AMAT4 = &quot;Assembly Material IV&quot;&#10;    AMAT5 = &quot;Assembly Material V&quot;&#10;    RARE = &quot;Rare Alloy&quot;&#10;    HULL_SEGMENT = &quot;Naval Hull Segment&quot;&#10;    SHELL_PLATING = &quot;Naval Shell Plating&quot;&#10;    TURB_COMP = &quot;Naval Turbine Components&quot;&#10;&#10;class RawResource(Enum):&#10;    ALUMINUM = &quot;Aluminum&quot;&#10;    SALVAGE = &quot;Salvage&quot;&#10;    COPPER = &quot;Copper&quot;&#10;    COAL = &quot;Coal&quot;&#10;    SULFUR = &quot;Sulfur&quot;&#10;    IRON = &quot;Iron&quot;&#10;    COMPONENTS = &quot;Components&quot;&#10;" />
              <option name="updatedContent" value="from enum import Enum&#10;&#10;class Material(Enum):&#10;    BMAT = &quot;Basic Material&quot;&#10;    RMAT = &quot;Refined Material&quot;&#10;    EMAT = &quot;Explosive Powder&quot;&#10;    HEMAT = &quot;High Explosive Powder&quot;&#10;    PCMAT = &quot;Processed Construction Material&quot;&#10;    CMAT = &quot;Construction Material&quot;&#10;    AMAT1 = &quot;Assembly Material I&quot;&#10;    AMAT2 = &quot;Assembly Material II&quot;&#10;    AMAT3 = &quot;Assembly Material III&quot;&#10;    AMAT4 = &quot;Assembly Material IV&quot;&#10;    AMAT5 = &quot;Assembly Material V&quot;&#10;    RARE = &quot;Rare Alloy&quot;&#10;    HULL_SEGMENT = &quot;Naval Hull Segment&quot;&#10;    SHELL_PLATING = &quot;Naval Shell Plating&quot;&#10;    TURB_COMP = &quot;Naval Turbine Components&quot;&#10;&#10;class RawResource(Enum):&#10;    ALUMINUM = &quot;Aluminum&quot;&#10;    SALVAGE = &quot;Salvage&quot;&#10;    COPPER = &quot;Copper&quot;&#10;    COAL = &quot;Coal&quot;&#10;    SULFUR = &quot;Sulfur&quot;&#10;    IRON = &quot;Iron&quot;&#10;    COMPONENTS = &quot;Components&quot;&#10;&#10;class ResourceField(Enum):&#10;    COAL_FIELD = &quot;Coal Field&quot;&#10;    COMPONENT_FIELD = &quot;Component Field&quot;&#10;    OIL_FIELD = &quot;Oil Field&quot;&#10;    SALVAGE_FIELD = &quot;Salvage Field&quot;&#10;    SULFUR_FIELD = &quot;Sulfur Field&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/data/static-game-data/db_models.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/static-game-data/db_models.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/data/discord/test_retry_env.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/data/discord/test_retry_env.py" />
              <option name="originalContent" value="import asyncio&#10;&#10;# Assume DiscordBot is imported from the correct location&#10;    # Ensure an event loop exists for tests that need it&#10;        loop = asyncio.new_event_loop()&#10;    # Clean up the event loop after each test&#10;    try:&#10;        asyncio.get_event_loop()&#10;        loop.close()&#10;    except RuntimeError:&#10;        pass&#10;&#10;def test_env_defaults(monkeypatch):&#10;    # Remove env vars if set&#10;    monkeypatch.delenv('DISCORD_BOT_MAX_RETRIES', raising=False)&#10;    monkeypatch.delenv('DISCORD_BOT_RETRY_DELAY', raising=False)&#10;    # Access the retry config (simulate how your code reads it)&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 3&#10;    assert retry_delay == 15&#10;&#10;def test_env_override(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '5')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '42')&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 5&#10;    assert retry_delay == 42&#10;&#10;def test_retry_on_exception(monkeypatch):&#10;    # Set retries to 2 for a quick test&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')  # No sleep delay&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()  # Mock logger to avoid real logging&#10;    # Mock client.run to always raise Exception&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should attempt to run 1 initial + 2 retries = 3 times&#10;    assert bot.client.run.call_count == 3&#10;    # Check that error and retry logs were called&#10;    assert bot.logger.error.call_count &gt;= 3&#10;    assert any('Attempting to reconnect' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_login_failure(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Mock client.run to raise LoginFailure&#10;    bot.client.run = mock.Mock(side_effect=LoginFailure('bad token'))&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    # Should only try once&#10;    assert bot.client.run.call_count == 1&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_no_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '0')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should only try once (no retries)&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_negative_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '-1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Class should only try once. Negative retries are treated as 0.&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_non_integer_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', 'abc')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_non_integer_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', 'xyz')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_zero_retry_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    # Patch sleep to track calls&#10;    with mock.patch('time.sleep') as mock_sleep:&#10;        with pytest.raises(Exception):&#10;            bot.run()&#10;        # Should attempt to run 1 initial + 2 retries = 3 times&#10;        assert bot.client.run.call_count == 3&#10;        # sleep should not be called since delay is 0&#10;        mock_sleep.assert_not_called()&#10;&#10;def test_retry_succeeds(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # First call fails, second call succeeds&#10;    bot.client.run = mock.Mock(side_effect=[Exception('fail'), None])&#10;    # Should not raise, since the second attempt succeeds&#10;    bot.run()&#10;    assert bot.client.run.call_count == 2&#10;    # Should log error for first failure, but not raise&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_shutdown_exception(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    bot.client.close = mock.Mock(side_effect=Exception('shutdown fail'))&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    # Should log the shutdown error&#10;    assert any('shutdown fail' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_on_ready_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Simulate event&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_sets_disconnected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;class DummyUser:&#10;    def __str__(self):&#10;        return &quot;TestUser&quot;&#10;&#10;def test_on_ready_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client with a mock that has a user property&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as TestUser' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_run_login_failure_non_mock(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client to not be a mock&#10;    class DummyClient:&#10;        def run(self, token):&#10;            raise LoginFailure('bad token')&#10;    bot.client = DummyClient()&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_shutdown_running_loop_add_done_callback(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = True&#10;            # Simulate create_task and add_done_callback&#10;            class DummyTask:&#10;                def add_done_callback(self, cb):&#10;                    cb(self)&#10;            mock_loop.create_task = mock.Mock(return_value=DummyTask())&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_shutdown_returns_if_client_closed(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=True)&#10;    # Should return early, not call close&#10;    bot.client.close = mock.Mock()&#10;    bot.shutdown()&#10;    bot.client.close.assert_not_called()&#10;&#10;def test_shutdown_returns_if_client_is_mock(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client = mock.Mock()&#10;    bot.client.is_closed.return_value = False&#10;    # Should return early if the client is a mock&#10;    bot.shutdown()&#10;    # Should not call close or log warning&#10;    assert not bot.logger.warning.called&#10;&#10;def test_shutdown_logs_warning_if_close_not_awaitable(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    # close returns a non-awaitable&#10;    bot.client.close = mock.Mock(return_value=None)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('did not return a coroutine' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_shutdown_logs_graceful_disconnect(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            # Simulate run_until_complete&#10;            def run_until_complete():&#10;                return None&#10;            mock_loop.run_until_complete = run_until_complete&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_is_connected():&#10;    bot = DiscordBot(token='dummy')&#10;    bot.connected = True&#10;    assert bot.is_connected() is True&#10;    bot.connected = False&#10;    assert bot.is_connected() is False&#10;" />
              <option name="updatedContent" value="import sys&#10;import os&#10;import pytest&#10;from unittest import mock&#10;import asyncio&#10;&#10;# Add the project root to sys.path so 'data' can be imported&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../..')))&#10;&#10;# Assume DiscordBot is imported from the correct location&#10;from data.discord.discord import DiscordBot&#10;&#10;def setup_function():&#10;    # Ensure an event loop exists for tests that need it&#10;    try:&#10;        asyncio.get_running_loop()&#10;    except RuntimeError:&#10;        loop = asyncio.new_event_loop()&#10;        asyncio.set_event_loop(loop)&#10;&#10;def teardown_function():&#10;    # Clean up the event loop after each test&#10;    try:&#10;        loop = asyncio.get_event_loop()&#10;        loop.close()&#10;    except RuntimeError:&#10;        pass&#10;&#10;def test_env_defaults(monkeypatch):&#10;    # Remove env vars if set&#10;    monkeypatch.delenv('DISCORD_BOT_MAX_RETRIES', raising=False)&#10;    monkeypatch.delenv('DISCORD_BOT_RETRY_DELAY', raising=False)&#10;    # Access the retry config (simulate how your code reads it)&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 3&#10;    assert retry_delay == 15&#10;&#10;def test_env_override(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '5')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '42')&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 5&#10;    assert retry_delay == 42&#10;&#10;def test_retry_on_exception(monkeypatch):&#10;    # Set retries to 2 for a quick test&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')  # No sleep delay&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()  # Mock logger to avoid real logging&#10;    # Mock client.run to always raise Exception&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should attempt to run 1 initial + 2 retries = 3 times&#10;    assert bot.client.run.call_count == 3&#10;    # Check that error and retry logs were called&#10;    assert bot.logger.error.call_count &gt;= 3&#10;    assert any('Attempting to reconnect' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_login_failure(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Mock client.run to raise LoginFailure&#10;    bot.client.run = mock.Mock(side_effect=LoginFailure('bad token'))&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    # Should only try once&#10;    assert bot.client.run.call_count == 1&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_no_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '0')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should only try once (no retries)&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_negative_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '-1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Class should only try once. Negative retries are treated as 0.&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_non_integer_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', 'abc')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_non_integer_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', 'xyz')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_zero_retry_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    # Patch sleep to track calls&#10;    with mock.patch('time.sleep') as mock_sleep:&#10;        with pytest.raises(Exception):&#10;            bot.run()&#10;        # Should attempt to run 1 initial + 2 retries = 3 times&#10;        assert bot.client.run.call_count == 3&#10;        # sleep should not be called since delay is 0&#10;        mock_sleep.assert_not_called()&#10;&#10;def test_retry_succeeds(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # First call fails, second call succeeds&#10;    bot.client.run = mock.Mock(side_effect=[Exception('fail'), None])&#10;    # Should not raise, since the second attempt succeeds&#10;    bot.run()&#10;    assert bot.client.run.call_count == 2&#10;    # Should log error for first failure, but not raise&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_shutdown_exception(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    bot.client.close = mock.Mock(side_effect=Exception('shutdown fail'))&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    # Should log the shutdown error&#10;    assert any('shutdown fail' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_on_ready_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Simulate event&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_sets_disconnected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;class DummyUser:&#10;    def __str__(self):&#10;        return &quot;TestUser&quot;&#10;&#10;def test_on_ready_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client with a mock that has a user property&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as TestUser' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_run_login_failure_non_mock(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client to not be a mock&#10;    class DummyClient:&#10;        def run(self, token):&#10;            raise LoginFailure('bad token')&#10;    bot.client = DummyClient()&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_shutdown_running_loop_add_done_callback(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = True&#10;            # Simulate create_task and add_done_callback&#10;            class DummyTask:&#10;                def add_done_callback(self, cb):&#10;                    cb(self)&#10;            mock_loop.create_task = mock.Mock(return_value=DummyTask())&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_shutdown_returns_if_client_closed(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=True)&#10;    # Should return early, not call close&#10;    bot.client.close = mock.Mock()&#10;    bot.shutdown()&#10;    bot.client.close.assert_not_called()&#10;&#10;def test_shutdown_returns_if_client_is_mock(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client = mock.Mock()&#10;    bot.client.is_closed.return_value = False&#10;    # Should return early if the client is a mock&#10;    bot.shutdown()&#10;    # Should not call close or log warning&#10;    assert not bot.logger.warning.called&#10;&#10;def test_shutdown_logs_warning_if_close_not_awaitable(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    # close returns a non-awaitable&#10;    bot.client.close = mock.Mock(return_value=None)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('did not return a coroutine' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_shutdown_logs_graceful_disconnect(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            # Simulate run_until_complete&#10;            def run_until_complete():&#10;                return None&#10;            mock_loop.run_until_complete = run_until_complete&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_is_connected():&#10;    bot = DiscordBot(token='dummy')&#10;    bot.connected = True&#10;    assert bot.is_connected() is True&#10;    bot.connected = False&#10;    assert bot.is_connected() is False" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>