<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/data/warapi/war_api_client.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/data/warapi/war_api_client.py" />
              <option name="originalContent" value="&quot;&quot;&quot;Client functions for interacting with FoxAPI and updating the local database with war, map, and report data.&quot;&quot;&quot;&#10;&#10;import datetime&#10;from dependencies.FoxAPI.FoxAPI.foxapi.foxapi import FoxAPI&#10;from data.db.db import Map, MapDynamic, MapStatic, War, WarReport, initialize_db&#10;&#10;# Initialize FoxAPI instance (singleton recommended)&#10;foxapi = FoxAPI()&#10;&#10;# Data access functions using FoxAPI&#10;def get_war():&#10;    &quot;&quot;&quot;&#10;    Fetches current war data from FoxAPI and updates the database.&#10;    Returns the war data as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_war_sync()&#10;    # Optionally update DB for historical tracking&#10;    War.replace(&#10;        war_id=data['warId'],&#10;        start_time=datetime.datetime.utcfromtimestamp(data['warStartTime'] / 1000),&#10;        resistance_phase=int(data['resistance']),&#10;        last_updated=datetime.datetime.utcnow()&#10;    ).execute()&#10;    return data&#10;&#10;&#10;def get_maps():&#10;    &quot;&quot;&quot;&#10;    Fetches map list from FoxAPI and updates the database.&#10;    Returns the list of maps as a list of dicts.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_maps_sync()&#10;    for m in data:&#10;        Map.replace(name=m['code'], display_name=m['name'], last_updated=datetime.datetime.utcnow()).execute()&#10;    return data&#10;&#10;def get_war_report(map_name):&#10;    &quot;&quot;&quot;&#10;    Fetches war report for a map from FoxAPI and updates the database.&#10;    Returns the report as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_war_report_sync(map_name)&#10;    WarReport.replace(&#10;        map_name=map_name,&#10;        casualties=data.get('totalCasualties', 0),&#10;        enlistments=data.get('totalEnlistments', 0),&#10;        last_updated=datetime.datetime.utcnow()&#10;    ).execute()&#10;    return data&#10;&#10;def get_map_static(map_name):&#10;    &quot;&quot;&quot;&#10;    Fetches static map data from FoxAPI and updates the database.&#10;    Returns the static data as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_static_sync(map_name)&#10;    MapStatic.replace(&#10;        map_name=map_name,&#10;        data=str(data),  # Store as stringified JSON&#10;        last_updated=datetime.datetime.utcnow()&#10;    ).execute()&#10;    return data&#10;&#10;def get_map_dynamic(map_name):&#10;    &quot;&quot;&quot;&#10;    Fetches dynamic map data from FoxAPI and updates the database.&#10;    Returns the dynamic data as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_dynamic_sync(map_name)&#10;    MapDynamic.replace(&#10;        map_name=map_name,&#10;        data=str(data),  # Store as stringified JSON&#10;        last_updated=datetime.datetime.utcnow()&#10;    ).execute()&#10;    return data&#10;&#10;# Call this at startup&#10;def setup():&#10;    initialize_db()&#10;&#10;# --- Aggregated Hexagon Data ---&#10;def get_hexagon_data(map_name):&#10;    &quot;&quot;&quot;&#10;    Returns a HexagonObject for the given map, containing war report, static, dynamic, captured towns, and casualty rate.&#10;    Uses FoxAPI's get_hexagon_data_sync for all-in-one access.&#10;    &quot;&quot;&quot;&#10;    return foxapi.get_hexagon_data_sync(map_name)&#10;&#10;# Example usage:&#10;# hex_data = get_hexagon_data('Deadlands')&#10;# print(hex_data.war_report)&#10;# print(hex_data.static)&#10;# print(hex_data.dynamic)&#10;# print(hex_data.captured_towns)&#10;# print(hex_data.casualty_rate)" />
              <option name="updatedContent" value="&quot;&quot;&quot;Client functions for interacting with FoxAPI and updating the local database with war, map, and report data.&quot;&quot;&quot;&#10;&#10;import datetime&#10;from dependencies.FoxAPI.FoxAPI.foxapi.foxapi import FoxAPI&#10;from data.db.db import Map, MapDynamic, MapStatic, War, WarReport, initialize_db&#10;&#10;# Initialize FoxAPI instance (singleton recommended)&#10;foxapi = FoxAPI()&#10;&#10;# Data access functions using FoxAPI&#10;def get_war():&#10;    &quot;&quot;&quot;&#10;    Fetches current war data from FoxAPI and updates the database.&#10;    Returns the war data as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_war_sync()&#10;    # Optionally update DB for historical tracking&#10;    War.replace(&#10;        war_id=data['warId'],&#10;        start_time=datetime.datetime.fromtimestamp(data['warStartTime'] / 1000, tz=datetime.timezone.utc),&#10;        resistance_phase=int(data['resistance']),&#10;        last_updated=datetime.datetime.now(datetime.timezone.utc)&#10;    ).execute()&#10;    return data&#10;&#10;&#10;def get_maps():&#10;    &quot;&quot;&quot;&#10;    Fetches map list from FoxAPI and updates the database.&#10;    Returns the list of maps as a list of dicts.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_maps_sync()&#10;    for m in data:&#10;        Map.replace(name=m['code'], display_name=m['name'], last_updated=datetime.datetime.now(datetime.timezone.utc)).execute()&#10;    return data&#10;&#10;def get_war_report(map_name):&#10;    &quot;&quot;&quot;&#10;    Fetches war report for a map from FoxAPI and updates the database.&#10;    Returns the report as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_war_report_sync(map_name)&#10;    WarReport.replace(&#10;        map_name=map_name,&#10;        casualties=data.get('totalCasualties', 0),&#10;        enlistments=data.get('totalEnlistments', 0),&#10;        last_updated=datetime.datetime.now(datetime.timezone.utc)&#10;    ).execute()&#10;    return data&#10;&#10;def get_map_static(map_name):&#10;    &quot;&quot;&quot;&#10;    Fetches static map data from FoxAPI and updates the database.&#10;    Returns the static data as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_static_sync(map_name)&#10;    MapStatic.replace(&#10;        map_name=map_name,&#10;        data=str(data),  # Store as stringified JSON&#10;        last_updated=datetime.datetime.now(datetime.timezone.utc)&#10;    ).execute()&#10;    return data&#10;&#10;def get_map_dynamic(map_name):&#10;    &quot;&quot;&quot;&#10;    Fetches dynamic map data from FoxAPI and updates the database.&#10;    Returns the dynamic data as a dict.&#10;    &quot;&quot;&quot;&#10;    data = foxapi.get_dynamic_sync(map_name)&#10;    MapDynamic.replace(&#10;        map_name=map_name,&#10;        data=str(data),  # Store as stringified JSON&#10;        last_updated=datetime.datetime.now(datetime.timezone.utc)&#10;    ).execute()&#10;    return data&#10;&#10;# Call this at startup&#10;def setup():&#10;    initialize_db()&#10;&#10;# --- Aggregated Hexagon Data ---&#10;def get_hexagon_data(map_name):&#10;    &quot;&quot;&quot;&#10;    Returns a HexagonObject for the given map, containing war report, static, dynamic, captured towns, and casualty rate.&#10;    Uses FoxAPI's get_hexagon_data_sync for all-in-one access.&#10;    &quot;&quot;&quot;&#10;    return foxapi.get_hexagon_data_sync(map_name)&#10;&#10;# Example usage:&#10;# hex_data = get_hexagon_data('Deadlands')&#10;# print(hex_data.war_report)&#10;# print(hex_data.static)&#10;# print(hex_data.dynamic)&#10;# print(hex_data.captured_towns)&#10;# print(hex_data.casualty_rate)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/pyproject.toml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/pyproject.toml" />
              <option name="originalContent" value="[project]&#10;name = &quot;Foxhole-Automated-Quartermaster&quot;&#10;version = &quot;0.1.0&quot;&#10;description = &quot;A logistics automation tool for the Foxhole game, designed to streamline the quartermaster's tasks.&quot;&#10;readme-content-type = &quot;text/markdown&quot;&#10;keywords = [&quot;foxhole&quot;, &quot;logistics&quot;, &quot;automation&quot;]&#10;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]&#10;license = &quot;GPT v3&quot;&#10;readme = &quot;README.md&quot;&#10;requires-python = &quot;&gt;=3.13&quot;&#10;&#10;[project.optional-dependencies]&#10;dev = [&#10;    &quot;bandit&gt;=1.7.0&quot;,&#10;]&#10;&#10;[build-system]&#10;requires = [&quot;setuptools&gt;=42&quot;, &quot;wheel&quot;]&#10;build-backend = &quot;setuptools.build_meta&quot;&#10;&#10;[tool.ruff]&#10;target-version = &quot;py313&quot;&#10;line-length = 120&#10;exclude = [&#10;    &quot;.git&quot;,&#10;    &quot;__pycache__&quot;,&#10;    &quot;.mypy_cache&quot;,&#10;    &quot;.ruff_cache&quot;,&#10;    &quot;build&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;venv&quot;,&#10;    &quot;env&quot;,&#10;    &quot;*.egg-info&quot;,&#10;    &quot;Stockpiler/&quot;,&#10;    &quot;dependencies/&quot;,&#10;]&#10;&#10;[tool.ruff.lint]&#10;select = [&#10;    &quot;A&quot;, # flake8-annotations&#10;    &quot;AIR&quot;, # airflow&#10;    &quot;ANN&quot;, # type annotations&#10;    &quot;ASYNC&quot;, # flake8-async&#10;    &quot;ARG&quot;, # falke8 unused arguments&#10;    &quot;B&quot;, # flake8-bugbear&#10;    &quot;BLE&quot;, # flake8-blind-except&#10;    &quot;COM&quot;, # flake8-commas (specifically trailing commas)&#10;    &quot;C&quot;, # complexity&#10;    &quot;C4&quot;, # flake8-comprehensions&#10;    &quot;C90&quot;, # flake8-90-complexity&#10;    &quot;D&quot;, # pydocstyle&#10;    &quot;DJ&quot;, # flake8-django&#10;    &quot;DTZ&quot;, # flake8-datetimez Timezone checks&#10;    &quot;E&quot;, # Error&#10;    &quot;EM&quot;, # Error messages&#10;    &quot;ERA&quot;, # eradicate commented out code&#10;    &quot;EXE&quot;, # flake8-executable&#10;    &quot;F&quot;, # pyflakes&#10;    &quot;FA&quot;, # flake8-future-annotations&#10;    &quot;FBT&quot;, # flake8-boolean-trap&#10;    &quot;FIX&quot;, # flake8 fix me&#10;    &quot;FLY&quot;, # flake8-flynt&#10;    &quot;FURB&quot;, # refur&#10;    &quot;G&quot;, # flake8-logging-format&#10;    &quot;I&quot;, # isort&#10;    &quot;ICN&quot;, # flake8-import-conventions&#10;    &quot;ISC&quot;, # flake8-implicit-str-concat&#10;    &quot;INT&quot;, # flake8-gettext&#10;    &quot;INP&quot;, # flake8-no-pep420&#10;    &quot;LOG&quot;, # flake8-logging&#10;    &quot;N&quot;, # pep8-naming&#10;    &quot;NPY&quot;, # NumPy specific rules&#10;    &quot;PERF&quot;, # Perflint: performance&#10;    &quot;PD&quot;, # flake8-pandas-vet&#10;    &quot;PIE&quot;, # flake8-pie&#10;    &quot;PLE&quot;, # errors related to Pylint&#10;    &quot;PLW&quot;, # warnings related to Pylint&#10;    &quot;PGH&quot;, # pygrep-hooks&#10;    &quot;PT&quot;, # pytest-style&#10;    &quot;PTH&quot;, # flake8-use-pathlib&#10;    &quot;PYI&quot;, # flake8-pyi&#10;    &quot;Q&quot;, # flake8-quotes&#10;    &quot;RET&quot;, # flake8-return&#10;    &quot;RUF&quot;, # Ruff specific rules&#10;    &quot;RSE&quot;, # flake8-raise&#10;    &quot;S&quot;, # bandit security checks&#10;    &quot;SIM&quot;, # flake8-simplify&#10;    &quot;SLF&quot;, # flake8-self&#10;    &quot;SLOT&quot;, # flake8-slots&#10;    &quot;T10&quot;, # flake8-debugger&#10;    &quot;TC&quot;, # flake8-type-checking&#10;    &quot;TD&quot;, # flake8-todos&#10;    &quot;TID&quot;, # flake8-tidy-imports&#10;    &quot;TRY&quot;, # tryceratops&#10;    &quot;SIM&quot;, # flake8-simplify&#10;    &quot;UP&quot;, # pyupgrade&#10;    &quot;W&quot;, # Warning&#10;    &quot;YTT&quot;, # flake8-2020&#10;]&#10;&#10;ignore = []&#10;&#10;[tool.ruff.format]&#10;quote-style = &quot;double&quot;&#10;indent-style = &quot;space&quot;&#10;skip-magic-trailing-comma = false&#10;line-ending = &quot;auto&quot;&#10;&#10;[tool.pyright]&#10;typeCheckingMode = &quot;strict&quot;" />
              <option name="updatedContent" value="[project]&#10;name = &quot;Foxhole-Automated-Quartermaster&quot;&#10;version = &quot;0.1.0&quot;&#10;description = &quot;A logistics automation tool for the Foxhole game, designed to streamline the quartermaster's tasks.&quot;&#10;readme-content-type = &quot;text/markdown&quot;&#10;keywords = [&quot;foxhole&quot;, &quot;logistics&quot;, &quot;automation&quot;]&#10;authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]&#10;license = &quot;GPT v3&quot;&#10;readme = &quot;README.md&quot;&#10;requires-python = &quot;&gt;=3.13&quot;&#10;&#10;[project.optional-dependencies]&#10;dev = [&#10;    &quot;bandit&gt;=1.7.0&quot;,&#10;]&#10;&#10;[build-system]&#10;requires = [&quot;setuptools&gt;=42&quot;, &quot;wheel&quot;]&#10;build-backend = &quot;setuptools.build_meta&quot;&#10;&#10;[tool.ruff]&#10;target-version = &quot;py313&quot;&#10;line-length = 120&#10;exclude = [&#10;    &quot;.git&quot;,&#10;    &quot;__pycache__&quot;,&#10;    &quot;.mypy_cache&quot;,&#10;    &quot;.ruff_cache&quot;,&#10;    &quot;build&quot;,&#10;    &quot;dist&quot;,&#10;    &quot;venv&quot;,&#10;    &quot;env&quot;,&#10;    &quot;*.egg-info&quot;,&#10;    &quot;Stockpiler/&quot;,&#10;    &quot;dependencies/&quot;,&#10;]&#10;&#10;[tool.ruff.lint]&#10;select = [&#10;    &quot;A&quot;, # flake8-annotations&#10;    &quot;AIR&quot;, # airflow&#10;    &quot;ANN&quot;, # type annotations&#10;    &quot;ASYNC&quot;, # flake8-async&#10;    &quot;ARG&quot;, # falke8 unused arguments&#10;    &quot;B&quot;, # flake8-bugbear&#10;    &quot;BLE&quot;, # flake8-blind-except&#10;    &quot;COM&quot;, # flake8-commas (specifically trailing commas)&#10;    &quot;C&quot;, # complexity&#10;    &quot;C4&quot;, # flake8-comprehensions&#10;    &quot;C90&quot;, # flake8-90-complexity&#10;    &quot;D&quot;, # pydocstyle&#10;    &quot;DJ&quot;, # flake8-django&#10;    &quot;DTZ&quot;, # flake8-datetimez Timezone checks&#10;    &quot;E&quot;, # Error&#10;    &quot;EM&quot;, # Error messages&#10;    &quot;ERA&quot;, # eradicate commented out code&#10;    &quot;EXE&quot;, # flake8-executable&#10;    &quot;F&quot;, # pyflakes&#10;    &quot;FA&quot;, # flake8-future-annotations&#10;    &quot;FBT&quot;, # flake8-boolean-trap&#10;    &quot;FIX&quot;, # flake8 fix me&#10;    &quot;FLY&quot;, # flake8-flynt&#10;    &quot;FURB&quot;, # refur&#10;    &quot;G&quot;, # flake8-logging-format&#10;    &quot;I&quot;, # isort&#10;    &quot;ICN&quot;, # flake8-import-conventions&#10;    &quot;ISC&quot;, # flake8-implicit-str-concat&#10;    &quot;INT&quot;, # flake8-gettext&#10;    &quot;INP&quot;, # flake8-no-pep420&#10;    &quot;LOG&quot;, # flake8-logging&#10;    &quot;N&quot;, # pep8-naming&#10;    &quot;NPY&quot;, # NumPy specific rules&#10;    &quot;PERF&quot;, # Perflint: performance&#10;    &quot;PD&quot;, # flake8-pandas-vet&#10;    &quot;PIE&quot;, # flake8-pie&#10;    &quot;PLE&quot;, # errors related to Pylint&#10;    &quot;PLW&quot;, # warnings related to Pylint&#10;    &quot;PGH&quot;, # pygrep-hooks&#10;    &quot;PT&quot;, # pytest-style&#10;    &quot;PTH&quot;, # flake8-use-pathlib&#10;    &quot;PYI&quot;, # flake8-pyi&#10;    &quot;Q&quot;, # flake8-quotes&#10;    &quot;RET&quot;, # flake8-return&#10;    &quot;RUF&quot;, # Ruff specific rules&#10;    &quot;RSE&quot;, # flake8-raise&#10;    &quot;S&quot;, # bandit security checks&#10;    &quot;SIM&quot;, # flake8-simplify&#10;    &quot;SLF&quot;, # flake8-self&#10;    &quot;SLOT&quot;, # flake8-slots&#10;    &quot;T10&quot;, # flake8-debugger&#10;    &quot;TC&quot;, # flake8-type-checking&#10;    &quot;TD&quot;, # flake8-todos&#10;    &quot;TID&quot;, # flake8-tidy-imports&#10;    &quot;TRY&quot;, # tryceratops&#10;    &quot;SIM&quot;, # flake8-simplify&#10;    &quot;UP&quot;, # pyupgrade&#10;    &quot;W&quot;, # Warning&#10;    &quot;YTT&quot;, # flake8-2020&#10;]&#10;&#10;ignore = []&#10;&#10;[tool.ruff.format]&#10;quote-style = &quot;double&quot;&#10;indent-style = &quot;space&quot;&#10;skip-magic-trailing-comma = false&#10;line-ending = &quot;auto&quot;&#10;&#10;[tool.pyright]&#10;typeCheckingMode = &quot;strict&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/tests/data/discord/test_retry_env.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/tests/data/discord/test_retry_env.py" />
              <option name="originalContent" value="import asyncio&#10;&#10;# Assume DiscordBot is imported from the correct location&#10;    # Ensure an event loop exists for tests that need it&#10;        loop = asyncio.new_event_loop()&#10;    # Clean up the event loop after each test&#10;    try:&#10;        asyncio.get_event_loop()&#10;        loop.close()&#10;    except RuntimeError:&#10;        pass&#10;&#10;def test_env_defaults(monkeypatch):&#10;    # Remove env vars if set&#10;    monkeypatch.delenv('DISCORD_BOT_MAX_RETRIES', raising=False)&#10;    monkeypatch.delenv('DISCORD_BOT_RETRY_DELAY', raising=False)&#10;    # Access the retry config (simulate how your code reads it)&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 3&#10;    assert retry_delay == 15&#10;&#10;def test_env_override(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '5')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '42')&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 5&#10;    assert retry_delay == 42&#10;&#10;def test_retry_on_exception(monkeypatch):&#10;    # Set retries to 2 for a quick test&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')  # No sleep delay&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()  # Mock logger to avoid real logging&#10;    # Mock client.run to always raise Exception&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should attempt to run 1 initial + 2 retries = 3 times&#10;    assert bot.client.run.call_count == 3&#10;    # Check that error and retry logs were called&#10;    assert bot.logger.error.call_count &gt;= 3&#10;    assert any('Attempting to reconnect' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_login_failure(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Mock client.run to raise LoginFailure&#10;    bot.client.run = mock.Mock(side_effect=LoginFailure('bad token'))&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    # Should only try once&#10;    assert bot.client.run.call_count == 1&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_no_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '0')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should only try once (no retries)&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_negative_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '-1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Class should only try once. Negative retries are treated as 0.&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_non_integer_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', 'abc')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_non_integer_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', 'xyz')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_zero_retry_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    # Patch sleep to track calls&#10;    with mock.patch('time.sleep') as mock_sleep:&#10;        with pytest.raises(Exception):&#10;            bot.run()&#10;        # Should attempt to run 1 initial + 2 retries = 3 times&#10;        assert bot.client.run.call_count == 3&#10;        # sleep should not be called since delay is 0&#10;        mock_sleep.assert_not_called()&#10;&#10;def test_retry_succeeds(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # First call fails, second call succeeds&#10;    bot.client.run = mock.Mock(side_effect=[Exception('fail'), None])&#10;    # Should not raise, since the second attempt succeeds&#10;    bot.run()&#10;    assert bot.client.run.call_count == 2&#10;    # Should log error for first failure, but not raise&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_shutdown_exception(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    bot.client.close = mock.Mock(side_effect=Exception('shutdown fail'))&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    # Should log the shutdown error&#10;    assert any('shutdown fail' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_on_ready_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Simulate event&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_sets_disconnected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;class DummyUser:&#10;    def __str__(self):&#10;        return &quot;TestUser&quot;&#10;&#10;def test_on_ready_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client with a mock that has a user property&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as TestUser' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_run_login_failure_non_mock(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client to not be a mock&#10;    class DummyClient:&#10;        def run(self, token):&#10;            raise LoginFailure('bad token')&#10;    bot.client = DummyClient()&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_shutdown_running_loop_add_done_callback(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = True&#10;            # Simulate create_task and add_done_callback&#10;            class DummyTask:&#10;                def add_done_callback(self, cb):&#10;                    cb(self)&#10;            mock_loop.create_task = mock.Mock(return_value=DummyTask())&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_shutdown_returns_if_client_closed(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=True)&#10;    # Should return early, not call close&#10;    bot.client.close = mock.Mock()&#10;    bot.shutdown()&#10;    bot.client.close.assert_not_called()&#10;&#10;def test_shutdown_returns_if_client_is_mock(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client = mock.Mock()&#10;    bot.client.is_closed.return_value = False&#10;    # Should return early if the client is a mock&#10;    bot.shutdown()&#10;    # Should not call close or log warning&#10;    assert not bot.logger.warning.called&#10;&#10;def test_shutdown_logs_warning_if_close_not_awaitable(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    # close returns a non-awaitable&#10;    bot.client.close = mock.Mock(return_value=None)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('did not return a coroutine' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_shutdown_logs_graceful_disconnect(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            # Simulate run_until_complete&#10;            def run_until_complete():&#10;                return None&#10;            mock_loop.run_until_complete = run_until_complete&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_is_connected():&#10;    bot = DiscordBot(token='dummy')&#10;    bot.connected = True&#10;    assert bot.is_connected() is True&#10;    bot.connected = False&#10;    assert bot.is_connected() is False&#10;" />
              <option name="updatedContent" value="import sys&#10;import os&#10;import pytest&#10;from unittest import mock&#10;import asyncio&#10;&#10;# Add the project root to sys.path so 'data' can be imported&#10;sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../..')))&#10;&#10;# Assume DiscordBot is imported from the correct location&#10;from data.discord.discord import DiscordBot&#10;&#10;def setup_function():&#10;    # Ensure an event loop exists for tests that need it&#10;    try:&#10;        asyncio.get_running_loop()&#10;    except RuntimeError:&#10;        loop = asyncio.new_event_loop()&#10;        asyncio.set_event_loop(loop)&#10;&#10;def teardown_function():&#10;    # Clean up the event loop after each test&#10;    try:&#10;        loop = asyncio.get_event_loop()&#10;        loop.close()&#10;    except RuntimeError:&#10;        pass&#10;&#10;def test_env_defaults(monkeypatch):&#10;    # Remove env vars if set&#10;    monkeypatch.delenv('DISCORD_BOT_MAX_RETRIES', raising=False)&#10;    monkeypatch.delenv('DISCORD_BOT_RETRY_DELAY', raising=False)&#10;    # Access the retry config (simulate how your code reads it)&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 3&#10;    assert retry_delay == 15&#10;&#10;def test_env_override(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '5')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '42')&#10;    max_retries = int(os.environ.get('DISCORD_BOT_MAX_RETRIES', 3))&#10;    retry_delay = int(os.environ.get('DISCORD_BOT_RETRY_DELAY', 15))&#10;    assert max_retries == 5&#10;    assert retry_delay == 42&#10;&#10;def test_retry_on_exception(monkeypatch):&#10;    # Set retries to 2 for a quick test&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')  # No sleep delay&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()  # Mock logger to avoid real logging&#10;    # Mock client.run to always raise Exception&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should attempt to run 1 initial + 2 retries = 3 times&#10;    assert bot.client.run.call_count == 3&#10;    # Check that error and retry logs were called&#10;    assert bot.logger.error.call_count &gt;= 3&#10;    assert any('Attempting to reconnect' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_login_failure(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Mock client.run to raise LoginFailure&#10;    bot.client.run = mock.Mock(side_effect=LoginFailure('bad token'))&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    # Should only try once&#10;    assert bot.client.run.call_count == 1&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_no_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '0')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Should only try once (no retries)&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_negative_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '-1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(Exception):&#10;        bot.run()&#10;    # Class should only try once. Negative retries are treated as 0.&#10;    assert bot.client.run.call_count == 1&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_non_integer_retries(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', 'abc')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_non_integer_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '1')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', 'xyz')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    with pytest.raises(ValueError):&#10;        bot.run()&#10;&#10;def test_zero_retry_delay(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.run = mock.Mock(side_effect=Exception('fail'))&#10;    # Patch sleep to track calls&#10;    with mock.patch('time.sleep') as mock_sleep:&#10;        with pytest.raises(Exception):&#10;            bot.run()&#10;        # Should attempt to run 1 initial + 2 retries = 3 times&#10;        assert bot.client.run.call_count == 3&#10;        # sleep should not be called since delay is 0&#10;        mock_sleep.assert_not_called()&#10;&#10;def test_retry_succeeds(monkeypatch):&#10;    monkeypatch.setenv('DISCORD_BOT_MAX_RETRIES', '2')&#10;    monkeypatch.setenv('DISCORD_BOT_RETRY_DELAY', '0')&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # First call fails, second call succeeds&#10;    bot.client.run = mock.Mock(side_effect=[Exception('fail'), None])&#10;    # Should not raise, since the second attempt succeeds&#10;    bot.run()&#10;    assert bot.client.run.call_count == 2&#10;    # Should log error for first failure, but not raise&#10;    assert bot.logger.error.call_count &gt;= 1&#10;&#10;def test_shutdown_exception(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    bot.client.close = mock.Mock(side_effect=Exception('shutdown fail'))&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    # Should log the shutdown error&#10;    assert any('shutdown fail' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_on_ready_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Simulate event&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_sets_disconnected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_sets_connected_and_logs(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;class DummyUser:&#10;    def __str__(self):&#10;        return &quot;TestUser&quot;&#10;&#10;def test_on_ready_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client with a mock that has a user property&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    asyncio.run(bot.on_ready())&#10;    assert bot.connected is True&#10;    assert any('Connected to Discord as TestUser' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_on_disconnect_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = True&#10;    asyncio.run(bot.on_disconnect())&#10;    assert bot.connected is False&#10;    assert any('Disconnected from Discord' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_on_resumed_with_user(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    class ClientWithUser:&#10;        user = 'TestUser'&#10;    bot.client = ClientWithUser()&#10;    bot.connected = False&#10;    asyncio.run(bot.on_resumed())&#10;    assert bot.connected is True&#10;    assert any('Reconnected to Discord.' in str(call) for call in bot.logger.info.call_args_list)&#10;&#10;def test_run_login_failure_non_mock(monkeypatch):&#10;    from disnake import LoginFailure&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    # Patch client to not be a mock&#10;    class DummyClient:&#10;        def run(self, token):&#10;            raise LoginFailure('bad token')&#10;    bot.client = DummyClient()&#10;    with pytest.raises(LoginFailure):&#10;        bot.run()&#10;    assert any('Authentication failed' in str(call) for call in bot.logger.error.call_args_list)&#10;&#10;def test_shutdown_running_loop_add_done_callback(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = True&#10;            # Simulate create_task and add_done_callback&#10;            class DummyTask:&#10;                def add_done_callback(self, cb):&#10;                    cb(self)&#10;            mock_loop.create_task = mock.Mock(return_value=DummyTask())&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_shutdown_returns_if_client_closed(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=True)&#10;    # Should return early, not call close&#10;    bot.client.close = mock.Mock()&#10;    bot.shutdown()&#10;    bot.client.close.assert_not_called()&#10;&#10;def test_shutdown_returns_if_client_is_mock(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client = mock.Mock()&#10;    bot.client.is_closed.return_value = False&#10;    # Should return early if the client is a mock&#10;    bot.shutdown()&#10;    # Should not call close or log warning&#10;    assert not bot.logger.warning.called&#10;&#10;def test_shutdown_logs_warning_if_close_not_awaitable(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    # close returns a non-awaitable&#10;    bot.client.close = mock.Mock(return_value=None)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('did not return a coroutine' in str(call) for call in bot.logger.warning.call_args_list)&#10;&#10;def test_shutdown_logs_graceful_disconnect(monkeypatch):&#10;    bot = DiscordBot(token='dummy')&#10;    bot.logger = mock.Mock()&#10;    bot.client.is_closed = mock.Mock(return_value=False)&#10;    async def fake_close():&#10;        # This is a fake coroutine to simulate close&#10;        pass&#10;    coro = fake_close()&#10;    bot.client.close = mock.Mock(return_value=coro)&#10;    # Patch asyncio to avoid real event loop usage&#10;    with mock.patch('asyncio.get_running_loop', side_effect=RuntimeError()):&#10;        with mock.patch('asyncio.new_event_loop') as mock_new_loop:&#10;            mock_loop = mock.Mock()&#10;            mock_new_loop.return_value = mock_loop&#10;            mock_loop.is_running.return_value = False&#10;            # Simulate run_until_complete&#10;            def run_until_complete():&#10;                return None&#10;            mock_loop.run_until_complete = run_until_complete&#10;            bot.shutdown(loop=mock_loop)&#10;    assert any('Bot disconnected gracefully.' in str(call) for call in bot.logger.info.call_args_list)&#10;    coro.close()&#10;&#10;def test_is_connected():&#10;    bot = DiscordBot(token='dummy')&#10;    bot.connected = True&#10;    assert bot.is_connected() is True&#10;    bot.connected = False&#10;    assert bot.is_connected() is False" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>